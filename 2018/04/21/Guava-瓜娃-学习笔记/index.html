<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Guava工程包含了若干被google的java项目广泛依赖的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [commonannotations] 、字符串处理 [string processing] 、I/O 等等。所有这些工具每天都在被G">
<meta property="og:type" content="article">
<meta property="og:title" content="Guava(瓜娃)学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/04/21/Guava-瓜娃-学习笔记/index.html">
<meta property="og:site_name" content="Duke Du的博客">
<meta property="og:description" content="Guava工程包含了若干被google的java项目广泛依赖的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [commonannotations] 、字符串处理 [string processing] 、I/O 等等。所有这些工具每天都在被G">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-21T10:39:15.467Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Guava(瓜娃)学习笔记">
<meta name="twitter:description" content="Guava工程包含了若干被google的java项目广泛依赖的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [commonannotations] 、字符串处理 [string processing] 、I/O 等等。所有这些工具每天都在被G">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/21/Guava-瓜娃-学习笔记/"/>





  <title>Guava(瓜娃)学习笔记 | Duke Du的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Duke Du的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/21/Guava-瓜娃-学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Duke Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duke Du的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Guava(瓜娃)学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-21T18:38:09+08:00">
                2018-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Guava工程包含了若干被google的java项目广泛依赖的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [commonannotations] 、字符串处理 [string processing] 、I/O 等等。所有这些工具每天都在被Google的工程师应用在产品服务中。</p>
<p>这些高质量的API可以使你的java代码更加优雅，更加简洁，让你的工作更加轻松愉悦，下面我们来开启Java编程学习之旅。</p>
<p>源码包的简单说明：</p>
<p>com.google.common.annotations：普通注解类型。</p>
<p>com.google.common.base：基本工具类库和接口。</p>
<p>com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。</p>
<p>com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。</p>
<p>com.google.common.eventbus：发布订阅风格的事件总线。</p>
<p>com.google.common.hash： 哈希工具包。</p>
<p>com.google.common.io：I/O工具包。</p>
<p>com.google.common.math：原始算术类型和超大数的运算工具包。</p>
<p>com.google.common.net：网络工具包。</p>
<p>com.google.common.primitives：八种原始类型和无符号类型的静态工具包。</p>
<p>com.google.common.reflect：反射工具包。</p>
<p>com.google.common.util.concurrent：多线程工具包。</p>
<h2 id="1-基本工具（Basic-utilities）"><a href="#1-基本工具（Basic-utilities）" class="headerlink" title="1.     基本工具（Basic utilities）"></a>1.     基本工具（Basic utilities）</h2><h3 id="1-使用和避免null（Optional）"><a href="#1-使用和避免null（Optional）" class="headerlink" title="1)    使用和避免null（Optional）"></a>1)    使用和避免null（Optional）</h3><p>null会引起歧义，会造成让人迷惑的错误，有时也会让人感到不爽。Guava中的许多工具遇到null时，会拒绝或者马上报错，而不是盲目的接受。</p>
<p>鉴于此google的guava库中提供了Optional接口来使null快速失败，即在可能为null的对象上做了一层封装，在使用Optional静态方法of时，如果传入的参数为null就抛出NullPointerException异常。</p>
<p>在Guava中Optional类就是用来强制提醒程序员，注意对Null的判断。</p>
<p>Optional的另外几个方法</p>
<p>Optional<t>.of(T)    为Optional赋值，当T为Null直接抛NullPointException,建议这个方法在调用的时候直接传常量，不要传变量</t></p>
<p>Optional<t>.fromNullable(T)  为Optional赋值，当T为Null则使用默认值。建议与or方法一起用，风骚无比</t></p>
<p>Optional<t>.absent()       为Optional赋值，采用默认值</t></p>
<p>T or(T)      当Optional的值为null时，使用or赋予的值返回。与fromNullable是一对好基友</p>
<p>T get()      当Optional的值为null时，抛出IllegalStateException，返回Optional的值</p>
<p>boolean isPresent() 如果Optional存在值，则返回True</p>
<p>T orNull() 当Optional的值为null时，则返回Null。否则返回Optional的值</p>
<p>Set<t> asSet() 将Optional中的值转为一个Set返回，当然只有一个值啦，或者为空，当值为null时。</t></p>
<p>使用Optional的意义？</p>
<p>使用Optional除了赋予null语义，增加了可读性，最大的优点在于它一种傻瓜式的防护，Optional迫使你积极思考引用缺失的情况，因为你必须显式地从Optional获取引用。直接使用null很容易让人忘掉某些情形，尽管FindBugs可以帮助查找null相关的问题，但是我们还是认为它并不能准确地定位问题根源。</p>
<h3 id="2-前提条件（Preconditions）"><a href="#2-前提条件（Preconditions）" class="headerlink" title="2)    前提条件（Preconditions）"></a>2)    前提条件（Preconditions）</h3><p>使方法的条件检查更简单。</p>
<p>Guava在Preconditions类中提供了若干前置条件判断的实用方法，我们强烈建议在Eclipse中静态导入这些方法。每个方法都有三个变种：</p>
<p>a)        没有额外参数：抛出的异常中没有错误消息；</p>
<p>b)        有一个Object对象作为额外参数：抛出的异常使用Object.toString() 作为错误消息；</p>
<p>c)        有一个String对象作为额外参数，并且有一组任意数量的附加Object对象：这个变种处理异常消息的方式有点类似printf，但考虑GWT的兼容性和效率，只支持%s指示符。</p>
<p>例如：查看源代码打印帮助</p>
<p>checkArgument(i&gt;= 0, “Argument was %s but expected nonnegative”, i);</p>
<p>checkArgument(i&lt; j, “Expected i &lt; j, but %s &gt; %s”, i, j);</p>
<table>
<thead>
<tr>
<th>方法声明（不包括额外参数）</th>
<th>描述</th>
<th>检查失败时抛出的异常</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkArgument(boolean)</td>
<td>检查boolean是否为true，用来检查传递给方法的参数。</td>
<td>IllegalArgumentException</td>
</tr>
<tr>
<td><strong>checkNotNull(T)</strong></td>
<td>检查value是否为null，该方法直接返回value，因此可以内嵌使用checkNotNull<code>。</code></td>
<td>NullPointerException</td>
</tr>
<tr>
<td><strong>checkState(boolean)</strong></td>
<td>用来检查对象的某些状态。</td>
<td>IllegalStateException</td>
</tr>
<tr>
<td><strong>checkElementIndex(int index, int size)</strong></td>
<td>检查index作为索引值对某个列表、字符串或数组是否有效。index&gt;=0 &amp;&amp; index&lt;size *</td>
<td>IndexOutOfBoundsException</td>
</tr>
<tr>
<td><strong>checkPositionIndex(int index, int size)</strong></td>
<td>检查index作为位置值对某个列表、字符串或数组是否有效。index&gt;=0 &amp;&amp; index&lt;=size *</td>
<td>IndexOutOfBoundsException</td>
</tr>
<tr>
<td>checkPositionIndexes(int start, int end, int size)</td>
<td>检查[start, end]表示的位置范围对某个列表、字符串或数组是否有效*</td>
<td>IndexOutOfBoundsException</td>
</tr>
</tbody>
</table>
<h3 id="3-常见的对象方法（Objects）"><a href="#3-常见的对象方法（Objects）" class="headerlink" title="3)    常见的对象方法（Objects）"></a>3)    常见的对象方法（Objects）</h3><p>简化Object方法实现，如hashCode()和toString()；</p>
<p>a)        equals</p>
<p>当一个对象中的字段可以为null时，实现Object.equals方法会很痛苦，因为不得不分别对它们进行null检查。使用Objects.equal帮助你执行null敏感的equals判断，从而避免抛出NullPointerException。</p>
<p>b)        hashCode</p>
<p>用对象的所有字段作散列[hash]运算应当更简单。Guava的Objects.hashCode(Object…)会对传入的字段序列计算出合理的、顺序敏感的散列值。你可以使用Objects.hashCode(field1, field2, …, fieldn)来代替手动计算散列值。</p>
<p>c)        toString</p>
<p>好的toString方法在调试时是无价之宝，但是编写toString方法有时候却很痛苦。使用 Objects.toStringHelper可以轻松编写有用的toString方法。</p>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4)    排序"></a>4)    排序</h3><p>Guava强大的”流畅风格比较器”,具体到下章会介绍到。</p>
<h3 id="5-Throwable类"><a href="#5-Throwable类" class="headerlink" title="5)    Throwable类"></a>5)    Throwable类</h3><p>简化了异常和错误的传播与检查；</p>
<p>guava类库中的Throwables提供了一些异常处理的静态方法，这些方法的从功能上分为两类，一类是帮你抛出异常，另外一类是帮你处理异常。</p>
<table>
<thead>
<tr>
<th>RuntimeException   propagate(Throwable)</th>
<th>如果Throwable是Error或RuntimeException，直接抛出；否则把Throwable包装成RuntimeException抛出。返回类型是RuntimeException，所以你可以像上面说的那样写成throw Throwables.propagate(t)，Java编译器会意识到这行代码保证抛出异常。</th>
</tr>
</thead>
<tbody>
<tr>
<td>void propagateIfInstanceOf( Throwable, Class<x extends="" exception="">) throws X</x></td>
<td>Throwable类型为X才抛出</td>
</tr>
<tr>
<td>void propagateIfPossible( Throwable)</td>
<td>Throwable类型为Error或RuntimeException才抛出</td>
</tr>
<tr>
<td>void   propagateIfPossible( Throwable, Class<x extends="" throwable="">) throws X</x></td>
<td>Throwable类型为X, Error或RuntimeException才抛出</td>
</tr>
</tbody>
</table>
<h2 id="2-集合（Collections）"><a href="#2-集合（Collections）" class="headerlink" title="2.     集合（Collections）"></a>2.     集合（Collections）</h2><p>介绍guava对jdk集合类的扩展，包括不可变集合，新集合类型: multisets, multimaps, tables, bidirectional maps等，强大的集合工具类: 提供java.util.Collections中没有的集合工具，扩展工具类：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器</p>
<p>集合API的使用, 可以简化集合的创建和初始化；</p>
<p>guava API 提供了有用的新的集合类型，协同已经存在的java集合工作的很好。</p>
<p>分别是 MultiMap， MultiSet， Table， BiMap，ClassToInstanceMap</p>
<h3 id="1-google-guava的不可变集合"><a href="#1-google-guava的不可变集合" class="headerlink" title="1)    google guava的不可变集合"></a>1)    google guava的不可变集合</h3><p>不可变对象有很多优点：</p>
<p>a)        当对象被不可信的库调用时，不可变形式是安全的。</p>
<p>b)        当不可变对象被对个线程调用时，不存在竞态条件问题；</p>
<p>c)        不可变集合不需要考虑变化，因此可以节约时间和空间，所有不可变集合都比可变集合形式有更好的内存利用率（分析和测试细节）；</p>
<p>d)        不可变对象因为有固定不变，可以用作常量来安全使用。</p>
<p>总结：数据不可变；不需要同步逻辑；线程安全；自由共享；容易设计和实现；内存和时间高效</p>
<p>创建对象的不可拷贝是一项很好的防御性编程技巧，Guava为所有JDK标准集合类型和Guava新集合类型都提供了简单易用的不可变版本。</p>
<p>JDK也提供了可以将集合变成不可变的方法，Collections.unmodifiableXXX，但是被认为是不好的。</p>
<p>a)        笨重而且累赘：不能舒适地用在所有想做防御性拷贝的场景；</p>
<p>b)        不安全：要保证没人通过原集合的引用进行修改，返回的集合才是事实上不可变的；</p>
<p>c)        低效：包装过的集合仍然保有可变集合的开销，比如并发修改的检查、散列表的额外空间，等等。</p>
<p>​       提示：guava不可变集合的实现都不接受null值，经过对google内部代码的研究发现，google内部只有不超过5%的情况下集合中允许了null值，其他情况下都不允许。如果我们相用null的不可变集合，那我们就用jdk中的集合类进行操作，然后进行集合工具类的处理Collections.unmodifiableXXX。</p>
<p>细节：关联可变集合和不可变集合</p>
<table>
<thead>
<tr>
<th>可变集合接口</th>
<th>属于jdk还是guava</th>
<th>不可变版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection</td>
<td>JDK</td>
<td>ImmutableCollection</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>ImmutableSet</td>
</tr>
<tr>
<td>SortedSet/NavigableSet</td>
<td>JDK</td>
<td>ImmutableSortedSet</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>ImmutableMap</td>
</tr>
<tr>
<td>SortedMultiset</td>
<td>Guava</td>
<td>ImmutableSortedMultiset</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>ImmutableMultimap</td>
</tr>
<tr>
<td>ListMultimap</td>
<td>Guava</td>
<td>ImmutableListMultimap</td>
</tr>
<tr>
<td>SetMultimap</td>
<td>Guava</td>
<td>ImmutableSetMultimap</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>ClassToInstanceMap</td>
<td>Guava</td>
<td>ImmutableClassToInstanceMap</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>ImmutableTable</td>
</tr>
</tbody>
</table>
<h3 id="2-google-guava集合之Multiset"><a href="#2-google-guava集合之Multiset" class="headerlink" title="2)    google guava集合之Multiset"></a>2)    google guava集合之Multiset</h3><p>Multiset看似是一个Set，但是实质上它不是一个Set，它没有继承Set接口，它继承的是Collection<e>接口，你可以向Multiset中添加重复的元素，Multiset会对添加的元素做一个计数。</e></p>
<p>它本质上是一个Set加一个元素计数器。</p>
<p>显然计数不是问题，Multiset还提供了add和remove的重载方法，可以在add或这remove的同时指定计数的值。</p>
<p>常用实现 Multiset 接口的类有：</p>
<p>HashMultiset: 元素存放于 HashMap</p>
<p>LinkedHashMultiset:元素存放于 LinkedHashMap，即元素的排列顺序由第一次放入的顺序决定</p>
<p>TreeMultiset:元素被排序存放于TreeMap</p>
<p>EnumMultiset: 元素必须是 enum 类型</p>
<p>ImmutableMultiset:不可修改的 Mutiset</p>
<p>看到这里你可能已经发现 GuavaCollections 都是以 create 或是 of 这样的静态方法来构造对象。这是因为这些集合类大多有多个参数的私有构造方法，由于参数数目很多，客户代码程序员使用起来就很不方便。而且以这种方式可以返回原类型的子类型对象。另外，对于创建范型对象来讲，这种方式更加简洁。</p>
<h3 id="3-google-guava的BiMap：双向Map"><a href="#3-google-guava的BiMap：双向Map" class="headerlink" title="3)    google guava的BiMap：双向Map"></a>3)    google guava的BiMap：双向Map</h3><p>我们知道Map是一种键值对映射，这个映射是键到值的映射，而BiMap首先也是一种Map，他的特别之处在于，既提供键到值的映射，也提供值到键的映射，所以它是双向Map.</p>
<p>BiMap的常用实现有：</p>
<p>HashBiMap: key 集合与 value 集合都有 HashMap 实现</p>
<p>EnumBiMap: key 与 value 都必须是 enum 类型</p>
<p>ImmutableBiMap: 不可修改的 BiMap</p>
<h3 id="4-google-guava的Multimaps：一键多值的Map"><a href="#4-google-guava的Multimaps：一键多值的Map" class="headerlink" title="4)    google guava的Multimaps：一键多值的Map"></a>4)    google guava的Multimaps：一键多值的Map</h3><p>有时候我们需要这样的数据类型Map&lt;String,Collection<string>&gt;，guava中的Multimap就是为了解决这类问题的。</string></p>
<p>Multimap提供了丰富的实现，所以你可以用它来替代程序里的Map&lt;K, Collection<v>&gt;，具体的实现如下：</v></p>
<table>
<thead>
<tr>
<th>实现</th>
<th>Key实现</th>
<th>Value实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayListMultimap</td>
<td>HashMap</td>
<td>ArrayList</td>
</tr>
<tr>
<td>HashMultimap</td>
<td>HashMap</td>
<td>HashSet</td>
</tr>
<tr>
<td>LinkedListMultimap</td>
<td>LinkedHashMap</td>
<td>LinkedList</td>
</tr>
<tr>
<td>LinkedHashMultimap</td>
<td>LinkedHashMap</td>
<td>LinkedHashSet</td>
</tr>
<tr>
<td>TreeMultimap</td>
<td>TreeMap</td>
<td>TreeSet</td>
</tr>
<tr>
<td>ImmutableListMultimap</td>
<td>ImmutableMap</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>ImmutableSetMultimap</td>
<td>ImmutableMap</td>
<td>ImmutableSet</td>
</tr>
</tbody>
</table>
<h3 id="5-google-guava集合之Table"><a href="#5-google-guava集合之Table" class="headerlink" title="5)    google guava集合之Table"></a>5)    google guava集合之Table</h3><p>在guava库中还提供了一种二维表结构：Table。使用Table可以实现二维矩阵的数据结构，可以是稀溜矩阵。</p>
<p>通常来说，当你想使用多个键做索引的时候，你可能会用类似Map&lt;FirstName, Map&lt;LastName, Person&gt;&gt;的实现，这种方式很丑陋，使用上也不友好。Guava为此提供了新集合类型Table，它有两个支持所有类型的键：”行”和”列”。Table提供多种视图，以便你从各种角度使用它：</p>
<p>rowMap()：用Map&lt;R, Map&lt;C, V&gt;&gt;表现Table&lt;R, C,V&gt;。同样的， rowKeySet()返回”行”的集合Set<r>。</r></p>
<p>row(r) ：用Map&lt;C, V&gt;返回给定”行”的所有列，对这个map进行的写操作也将写入Table中。</p>
<p>类似的列访问方法：columnMap()、columnKeySet()、column(c)。（基于列的访问会比基于的行访问稍微低效点）</p>
<p>cellSet()：用元素类型为Table.Cell&lt;R, C, V&gt;的Set表现Table&lt;R,C, V&gt;。Cell类似于Map.Entry，但它是用行和列两个键区分的。</p>
<h3 id="6-Guava集合：使用Iterators简化Iterator操作"><a href="#6-Guava集合：使用Iterators简化Iterator操作" class="headerlink" title="6)    Guava集合：使用Iterators简化Iterator操作"></a>6)    Guava集合：使用Iterators简化Iterator操作</h3><p>Iterators是Guava中对Iterator迭代器操作的帮助类，这个类提供了很多有用的方法来简化Iterator的操作。</p>
<h3 id="7-ClassToInstanceMap可以实现map的key值是多个类型"><a href="#7-ClassToInstanceMap可以实现map的key值是多个类型" class="headerlink" title="7)    ClassToInstanceMap可以实现map的key值是多个类型"></a>7)    ClassToInstanceMap可以实现map的key值是多个类型</h3><p>有的时候，你的map的key并不是一种类型，他们是很多类型，你想通过映射他们得到这种类型，guava提供了ClassToInstanceMap满足了这个目的。</p>
<p>除了继承自Map接口，ClassToInstaceMap提供了方法 TgetInstance(Class<t>) 和 T putInstance(Class<t>, T),消除了强制类型转换。</t></t></p>
<h3 id="8-Ordering犀利的比较器"><a href="#8-Ordering犀利的比较器" class="headerlink" title="8)    Ordering犀利的比较器"></a>8)    Ordering犀利的比较器</h3><p>Ordering是Guava类库提供的一个犀利强大的比较器工具，Guava的Ordering和JDK Comparator相比功能更强。它非常容易扩展，可以轻松构造复杂的comparator，然后用在容器的比较、排序等操作中。</p>
<p>本质上来说，Ordering实例无非就是一个特殊的Comparator 实例。Ordering只是需要依赖于一个比较器（例如，Collections.max）的方法，并使其可作为实例方法。另外，Ordering提供了链式方法调用和加强现有的比较器。</p>
<p>常见的静态方法：</p>
<p>natural()：使用Comparable类型的自然顺序，例如：整数从小到大，字符串是按字典顺序;</p>
<p>usingToString() ：使用toString()返回的字符串按字典顺序进行排序；</p>
<p>arbitrary() ：返回一个所有对象的任意顺序，即compare(a, b) == 0 就是 a == b (identity equality)。 本身的排序是没有任何含义， 但是在VM的生命周期是一个常量。</p>
<h3 id="9-ComparisonChain比较"><a href="#9-ComparisonChain比较" class="headerlink" title="9)    ComparisonChain比较"></a>9)    ComparisonChain比较</h3><p>实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起。考虑一下这种情况：</p>
<p>class Studentimplements Comparable<student>{</student></p>
<p>​         private String lastName;</p>
<p>​         private String firstName;</p>
<p>​         private int zipCode;</p>
<p>​         //jdk</p>
<p>​         public int compareTo(Student other) {</p>
<p>​                   int cmp =lastName.compareTo(other.lastName);</p>
<p>​            if (cmp != 0) {</p>
<p>​              return cmp;</p>
<p>​            }</p>
<p>​            cmp = firstName.compareTo(other.firstName);</p>
<p>​            if (cmp != 0) {</p>
<p>​              return cmp;</p>
<p>​            }</p>
<p>​            return Integer.compare(zipCode, other.zipCode);</p>
<p>​         }</p>
<p>}</p>
<p>这部分代码太琐碎了，因此很容易搞乱，也很难调试。我们应该能把这种代码变得更优雅，为此，Guava提供了ComparisonChain。</p>
<p>ComparisonChain执行一种懒比较：它执行比较操作直至发现非零的结果，在那之后的比较输入将被忽略。</p>
<p>//guava比较优雅</p>
<p>​         public int compareTo(Student other) {</p>
<p>​                   returnComparisonChain.start()</p>
<p>​                     .compare(this.lastName,other.lastName)</p>
<p>​                     .compare(this.firstName,other.firstName)</p>
<p>​                     .compare(this.zipCode,other.zipCode, Ordering.natural().nullsLast())</p>
<p>​                     .result();</p>
<p>​         }</p>
<p>这种Fluent接口风格的可读性更高，发生错误编码的几率更小，并且能避免做不必要的工作。</p>
<h2 id="3-缓存（Caches）"><a href="#3-缓存（Caches）" class="headerlink" title="3.     缓存（Caches）"></a>3.     缓存（Caches）</h2><p>google guava框架提供了内存缓存的功能，可以很方便的缓存对象，设置生命周期, 及缓存对象的弱引用强应用 软引用等</p>
<h3 id="1-使用google-guava做内存缓存"><a href="#1-使用google-guava做内存缓存" class="headerlink" title="1)    使用google guava做内存缓存"></a>1)    <a href="http://outofmemory.cn/java/guava/cache/how-to-use-guava-cache" target="_blank" rel="noopener">使用google guava做内存缓存</a></h3><p>google guava中有cache包，此包提供内存缓存功能。内存缓存需要考虑很多问题，包括并发问题，缓存失效机制，内存不够用时缓存释放，缓存的命中率，缓存的移除等等。当然这些东西guava都考虑到了。</p>
<p>guava的内存缓存非常强大，可以设置各种选项，而且很轻量，使用方便。另外还提供了下面一些方法，来方便各种需要：</p>
<p>ImmutableMap&lt;K, V&gt; getAllPresent(Iterable&lt;?&gt; keys) 一次获得多个键的缓存值</p>
<p>put和putAll方法向缓存中添加一个或者多个缓存项</p>
<p>invalidate 和 invalidateAll方法从缓存中移除缓存项</p>
<p>asMap()方法获得缓存数据的ConcurrentMap&lt;K, V&gt;快照</p>
<p>cleanUp()清空缓存</p>
<p>refresh(Key) 刷新缓存，即重新取缓存数据，更新缓存</p>
<h3 id="2-google-guava缓存分析"><a href="#2-google-guava缓存分析" class="headerlink" title="2)    google guava缓存分析"></a>2)    google guava缓存分析</h3><p>guava缓存过期时间分为两种，一种是从写入时开始计时，一种是从最后访问时间开始计时，而且guava缓存的过期时间是设置到整个一组缓存上的；这和EHCache，redis，memcached等不同，这些缓存系统设置都将缓存时间设置到了单个缓存上。</p>
<p>guava缓存设计成了一组对象一个缓存实例，这样做的好处是一组对象设置一组缓存策略，你可以根据不同的业务来设置不同的缓存策略，包括弱引用，软引用，过期时间，最大项数等。另外一点好处是你可以根据不同的组来统计缓存的命中率，这样更有意义一些。</p>
<p>这样做也是有缺点的，缺点是首先是每个缓存组都需要声明不同的缓存实例，具体到业务程序中可能就是每个业务对象一个缓存了。这样就把不同的业务缓存分散到不同的业务系统中了，不太好管理。</p>
<h2 id="4-函数式风格（Functional-idioms）"><a href="#4-函数式风格（Functional-idioms）" class="headerlink" title="4.     函数式风格（Functional idioms）"></a>4.     函数式风格（Functional idioms）</h2><h2 id="5-并发（Concurrency）"><a href="#5-并发（Concurrency）" class="headerlink" title="5.     并发（Concurrency）"></a>5.     并发（Concurrency）</h2><p>并发编程是一个难题，但是一个强大而简单的抽象可以显著的简化并发的编写。出于这样的考虑，Guava 定义了 ListenableFuture接口并继承了JDK concurrent包下的Future 接口。</p>
<h3 id="1-Guava并发：ListenableFuture使用介绍以及示例"><a href="#1-Guava并发：ListenableFuture使用介绍以及示例" class="headerlink" title="1)    Guava并发：ListenableFuture使用介绍以及示例"></a>1)    Guava并发：ListenableFuture使用介绍以及示例</h3><p>ListenableFuture顾名思义就是可以监听的Future，它是对java原生Future的扩展增强，本文介绍ListenableFuture的用法和扩展实现</p>
<p>ListenableFuture顾名思义就是可以监听的Future，它是对java原生Future的扩展增强。我们知道Future表示一个异步计算任务，当任务完成时可以得到计算结果。如果我们希望一旦计算完成就拿到结果展示给用户或者做另外的计算，就必须使用另一个线程不断的查询计算状态。这样做，代码复杂，而且效率低下。使用ListenableFuture Guava帮我们检测Future是否完成了，如果完成就自动调用回调函数，这样可以减少并发程序的复杂度。</p>
<p>另外ListenableFuture还有其他几种内置实现：</p>
<p>SettableFuture：不需要实现一个方法来计算返回值，而只需要返回一个固定值来做为返回值，可以通过程序设置此Future的返回值或者异常信息</p>
<p>CheckedFuture：这是一个继承自ListenableFuture接口，他提供了checkedGet()方法，此方法在Future执行发生异常时，可以抛出指定类型的异常。</p>
<h3 id="2-Guava并发：RateLimiter限制资源的并发访问线程数"><a href="#2-Guava并发：RateLimiter限制资源的并发访问线程数" class="headerlink" title="2)    Guava并发：RateLimiter限制资源的并发访问线程数"></a>2)    Guava并发：RateLimiter限制资源的并发访问线程数</h3><p>RateLimiter类似于JDK的信号量Semphore，他用来限制对资源并发访问的线程数</p>
<p>RateLimiter类似于JDK的信号量Semphore，他用来限制对资源并发访问的线程数。</p>
<p>RateLimiterlimiter = RateLimiter.create(4.0);//每秒不超过4个任务被提交</p>
<p>limiter.acquire();  //请求RateLimiter,超过permits会被阻塞</p>
<p>executor.submit(runnable);//提交任务</p>
<p>也可以以非阻塞的形式来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If(limiter.tryAcquire())&#123; //未请求到limiter则立即返回false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;else&#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomethingElse();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Guava并发：使用Monitor控制并发"><a href="#3-Guava并发：使用Monitor控制并发" class="headerlink" title="3)    Guava并发：使用Monitor控制并发"></a>3)    Guava并发：使用Monitor控制并发</h3><p>Monitor就像java原生的synchronized,ReentrantLock一样，每次只允许一个线程执行代码块，且可重占用，每一次占用要对应一次退出占用。</p>
<p>/**</p>
<ul>
<li><p>通过Monitor的Guard进行条件阻塞</p>
<p>*/</p>
</li>
</ul>
<p>public classMonitorSample {</p>
<p>   private List<string> list = new ArrayList<string>();</string></string></p>
<p>   private static final int MAX_SIZE = 10;</p>
<p>   private Monitor monitor = new Monitor();</p>
<p>​    </p>
<p>   private Monitor.Guard listBelowCapacity = new Monitor.Guard(monitor) {</p>
<p>​       @Override</p>
<p>​       public boolean isSatisfied() {</p>
<p>​           return list.size() &lt; MAX_SIZE;</p>
<p>​       }</p>
<p>​    };</p>
<p>   public void addToList(String item) throws InterruptedException {</p>
<p>​       monitor.enterWhen(listBelowCapacity); //Guard(形如Condition)，不满足则阻塞，而且我们并没有在Guard进行任何通知操作</p>
<p>​       try {</p>
<p>​           list.add(item);</p>
<p>​       } finally {</p>
<p>​           monitor.leave();</p>
<p>​       }</p>
<p>​    }</p>
<p>}</p>
<p>就如上面，我们通过if条件来判断是否可进入Monitor代码块，并再try/finally中释放：</p>
<p>if(monitor.enterIf(guardCondition)) {</p>
<p>​       try {</p>
<p>​             doWork();</p>
<p>​    }finally {</p>
<p>​          monitor.leave();</p>
<p>​      }</p>
<p>}</p>
<p>其他的Monitor访问方法：</p>
<p>Monitor.enter //进入Monitor块，将阻塞其他线程直到Monitor.leave</p>
<p>Monitor.tryEnter//尝试进入Monitor块，true表示可以进入, false表示不能，并且不会一直阻塞</p>
<p>Monitor.tryEnterIf//根据条件尝试进入Monitor块</p>
<p>这几个方法都有对应的超时设置版本。</p>
<h2 id="6-字符串处理（Strings）"><a href="#6-字符串处理（Strings）" class="headerlink" title="6.     字符串处理（Strings）"></a>6.     字符串处理（Strings）</h2><h3 id="1-连接器（Joiner）"><a href="#1-连接器（Joiner）" class="headerlink" title="1)    连接器（Joiner）"></a>1)    连接器（Joiner）</h3><p>用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有null，那连接操作会更难。Fluent风格的Joiner让连接字符串更简单。</p>
<p>警告：joiner实例总是不可变的。用来定义joiner目标语义的配置方法总会返回一个新的joiner实例。这使得joiner实例都是线程安全的，你可以将其定义为staticfinal常量。</p>
<h3 id="2-拆分器（Splitter）"><a href="#2-拆分器（Splitter）" class="headerlink" title="2)    拆分器（Splitter）"></a>2)    拆分器（Splitter）</h3><p>JDK内建的字符串拆分工具有一些古怪的特性。比如，String.split悄悄丢弃了尾部的分隔符。例如：</p>
<p>”,a,,b,”.split(“,”)    //””, “a”, “”, “b”      只有尾部的空字符串被忽略了</p>
<p>Splitter使用令人放心的、直白的流畅API模式对这些混乱的特性作了完全的掌控。</p>
<p>a)        拆分器工厂：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Splitter.on(char)</td>
<td>按单个字符拆分</td>
</tr>
<tr>
<td>Splitter.on(CharMatcher)</td>
<td>按字符匹配器拆分</td>
</tr>
<tr>
<td>Splitter.on(String)</td>
<td>按字符串拆分</td>
</tr>
<tr>
<td>Splitter.on(Pattern)Splitter.onPattern(String)</td>
<td>按正则表达式拆分</td>
</tr>
<tr>
<td>Splitter.fixedLength(int)</td>
<td>按固定长度拆分；最后一段可能比给定长度短，但不会为空。</td>
</tr>
</tbody>
</table>
<p>b)        拆分器修饰符：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>omitEmptyStrings()</td>
<td>从结果中自动忽略空字符串</td>
</tr>
<tr>
<td>trimResults()</td>
<td>移除结果字符串的前导空白和尾部空白</td>
</tr>
<tr>
<td>trimResults(CharMatcher)</td>
<td>给定匹配器，移除结果字符串的前导匹配字符和尾部匹配字符</td>
</tr>
<tr>
<td>limit(int)</td>
<td>限制拆分出的字符串数量</td>
</tr>
</tbody>
</table>
<p>如果你想要拆分器返回List，只要使用Lists.newArrayList(splitter.split(string))或类似方法。 警告：splitter实例总是不可变的。用来定义splitter目标语义的配置方法总会返回一个新的splitter实例。这使得splitter实例都是线程安全的，你可以将其定义为static final常量。</p>
<h3 id="3-字符匹配器（CharMatcher）"><a href="#3-字符匹配器（CharMatcher）" class="headerlink" title="3)    字符匹配器（CharMatcher）"></a>3)    字符匹配器（CharMatcher）</h3><p>然而使用CharMatcher的好处更在于它提供了一系列方法，让你对字符作特定类型的操作：修剪[trim]、折叠[collapse]、移除[remove]、保留[retain]等等。CharMatcher实例首先代表概念1：怎么才算匹配字符？然后它还提供了很多操作概念2：如何处理这些匹配字符？这样的设计使得API复杂度的线性增加可以带来灵活性和功能两方面的增长。</p>
<p>注：CharMatcher只处理char类型代表的字符；它不能理解0x10000到0x10FFFF的Unicode增补字符。这些逻辑字符以代理对[surrogatepairs]的形式编码进字符串，而CharMatcher只能将这种逻辑字符看待成两个独立的字符。</p>
<h3 id="4-字符集（Charsets）"><a href="#4-字符集（Charsets）" class="headerlink" title="4)    字符集（Charsets）"></a>4)    字符集（Charsets）</h3><p>Charsets针对所有Java平台都要保证支持的六种字符集提供了常量引用。尝试使用这些常量，而不是通过名称获取字符集实例。</p>
<h3 id="5-大小写格式（CaseFormat）"><a href="#5-大小写格式（CaseFormat）" class="headerlink" title="5)    大小写格式（CaseFormat）"></a>5)    大小写格式（CaseFormat）</h3><p>CaseFormat被用来方便地在各种ASCII大小写规范间转换字符串——比如，编程语言的命名规范。CaseFormat支持的格式如下：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOWER_CAMEL</td>
<td>lowerCamel</td>
</tr>
<tr>
<td>LOWER_HYPHEN</td>
<td>lower-hyphen</td>
</tr>
<tr>
<td>LOWER_UNDERSCORE</td>
<td>lower_underscore</td>
</tr>
<tr>
<td>UPPER_CAMEL</td>
<td>UpperCamel</td>
</tr>
<tr>
<td>UPPER_UNDERSCORE</td>
<td>UPPER_UNDERSCORE</td>
</tr>
</tbody>
</table>
<p>CaseFormat的用法很直接：        </p>
<p>CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,”CONSTANT_NAME”</p>
<p>)); // returns “constantName”</p>
<p>我们CaseFormat在某些时候尤其有用，比如编写代码生成器的时候。</p>
<h2 id="7-原生类型（Primitives）"><a href="#7-原生类型（Primitives）" class="headerlink" title="7.     原生类型（Primitives）"></a>7.     原生类型（Primitives）</h2><p>Java的原生类型也称原始类型，也是基本数据类型byte、short、int、long、float、double、char和boolean。</p>
<p>在从Guava查找原生类型方法之前，可以先查查Arrays类，或者对应的基础类型包装类，如Integer。</p>
<p>原生类型不能当作对象或泛型的类型参数使用，这意味着许多通用方法都不能应用于它们。Guava提供了若干通用工具，包括原生类型数组与集合API的交互，原生类型和字节数组的相互转换，以及对某些原生类型的无符号形式的支持。</p>
<table>
<thead>
<tr>
<th>原生类型</th>
<th>Guava工具类（都在com.google.common.primitives包）</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Bytes, SignedBytes, UnsignedBytes</td>
</tr>
<tr>
<td>short</td>
<td>Shorts</td>
</tr>
<tr>
<td>int</td>
<td>Ints, UnsignedInteger, UnsignedInts</td>
</tr>
<tr>
<td>long</td>
<td>Longs, UnsignedLong, UnsignedLongs</td>
</tr>
<tr>
<td>float</td>
<td>Floats</td>
</tr>
<tr>
<td>double</td>
<td>Doubles</td>
</tr>
<tr>
<td>char</td>
<td>Chars</td>
</tr>
<tr>
<td>boolean</td>
<td>Booleans</td>
</tr>
</tbody>
</table>
<p>Bytes工具类没有定义任何区分有符号和无符号字节的方法，而是把它们都放到了SignedBytes和UnsignedBytes工具类中，因为字节类型的符号性比起其它类型要略微含糊一些。</p>
<p>int和long的无符号形式方法在UnsignedInts和UnsignedLongs类中，但由于这两个类型的大多数用法都是有符号的，Ints和Longs类按照有符号形式处理方法的输入参数。</p>
<p>此外，Guava为int和long的无符号形式提供了包装类，即UnsignedInteger和UnsignedLong，以帮助你使用类型系统，以极小的性能消耗对有符号和无符号值进行强制转换。</p>
<p>原生类型数组工具:</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>List<wrapper> asList(prim… backingArray)</wrapper></td>
<td>把数组转为相应包装类的List</td>
</tr>
<tr>
<td>prim[] toArray(Collection<wrapper> collection)</wrapper></td>
<td>把集合拷贝为数组，和collection.toArray()一样线程安全</td>
</tr>
<tr>
<td>prim[] concat(prim[]… arrays)</td>
<td>串联多个原生类型数组</td>
</tr>
<tr>
<td>boolean contains(prim[] array, prim target)</td>
<td>判断原生类型数组是否包含给定值</td>
</tr>
<tr>
<td>int indexOf(prim[] array, prim target)</td>
<td>给定值在数组中首次出现处的索引，若不包含此值返回-1</td>
</tr>
<tr>
<td>int lastIndexOf(prim[] array, prim target)</td>
<td>给定值在数组最后出现的索引，若不包含此值返回-1</td>
</tr>
<tr>
<td>prim min(prim… array)</td>
<td>数组中最小的值</td>
</tr>
<tr>
<td>prim max(prim… array)</td>
<td>数组中最大的值</td>
</tr>
<tr>
<td>String join(String separator, prim… array)</td>
<td>把数组用给定分隔符连接为字符串</td>
</tr>
<tr>
<td>Comparator&lt;prim[]&gt;   lexicographicalComparator()</td>
<td>按字典序比较原生类型数组的Comparator</td>
</tr>
</tbody>
</table>
<p>*符号无关方法存在于Bytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans。而UnsignedInts,UnsignedLongs, SignedBytes, 或UnsignedBytes不存在。</p>
<p>*符号相关方法存在于SignedBytes, UnsignedBytes, Shorts, Ints, Longs, Floats, Doubles,Chars, Booleans, UnsignedInts, UnsignedLongs。而Bytes不存在。</p>
<p>通用工具方法：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int compare(prim a, prim b)</td>
<td>传统的Comparator.compare方法，但针对原生类型。JDK7的原生类型包装类也提供这样的方法</td>
</tr>
<tr>
<td>prim checkedCast(long value)</td>
<td>把给定long值转为某一原生类型，若给定值不符合该原生类型，则抛出IllegalArgumentException</td>
</tr>
<tr>
<td>prim saturatedCast(long value)</td>
<td>把给定long值转为某一原生类型，若给定值不符合则使用最接近的原生类型值</td>
</tr>
</tbody>
</table>
<p>*这里的整型包括byte, short, int, long。不包括char, boolean, float, 或double。</p>
<p>字节转换方法：</p>
<p>Guava提供了若干方法，用来把原生类型按大字节序与字节数组相互转换。所有这些方法都是符号无关的，此外Booleans没有提供任何下面的方法。</p>
<table>
<thead>
<tr>
<th>方法签名或字段签名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int BYTES</td>
<td>常量：表示该原生类型需要的字节数</td>
</tr>
<tr>
<td>prim fromByteArray(byte[] bytes)</td>
<td>使用字节数组的前Prims.BYTES个字节，按大字节序返回原生类型值；如果bytes.length &lt;= Prims.BYTES，抛出IAE</td>
</tr>
<tr>
<td>prim fromBytes(byte b1, …, byte bk)</td>
<td>接受Prims.BYTES个字节参数，按大字节序返回原生类型值</td>
</tr>
<tr>
<td>byte[] toByteArray(prim value)</td>
<td>按大字节序返回value的字节数组</td>
</tr>
</tbody>
</table>
<h2 id="8-区间（Ranges）"><a href="#8-区间（Ranges）" class="headerlink" title="8.     区间（Ranges）"></a>8.     区间（Ranges）</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1)    简介"></a>1)    简介</h3><p>区间，有时也称为范围，是特定域中的凸性（非正式说法为连续的或不中断的）部分。在形式上，凸性表示对a&lt;=b&lt;=c, range.contains(a)且range.contains(c)意味着range.contains(b)。</p>
<p>区间可以延伸至无限——例如，范围”x&gt;3″包括任意大于3的值——也可以被限制为有限，如” 2&lt;=x&lt;5″。Guava用更紧凑的方法表示范围，有数学背景的程序员对此是耳熟能详的：</p>
<p>(a..b) = {x | a &lt; x &lt; b}</p>
<p>[a..b] = {x | a &lt;= x &lt;= b}</p>
<p>[a..b) = {x | a &lt;= x &lt; b}</p>
<p>(a..b] = {x | a &lt; x &lt;= b}</p>
<p>(a..+∞) = {x | x &gt; a}</p>
<p>[a..+∞) = {x | x &gt;= a}</p>
<p>(-∞..b) = {x | x &lt; b}</p>
<p>(-∞..b] = {x | x &lt;= b}</p>
<p>(-∞..+∞) = 所有值</p>
<p>上面的a、b称为端点 。为了提高一致性，Guava中的Range要求上端点不能小于下端点。上下端点有可能是相等的，但要求区间是闭区间或半开半闭区间（至少有一个端点是包含在区间中的）：</p>
<p>[a..a]：单元素区间</p>
<p>[a..a); (a..a]：空区间，但它们是有效的</p>
<p>(a..a)：无效区间</p>
<p>Guava用类型Range<c>表示区间。所有区间实现都是不可变类型。</c></p>
<h3 id="2-构建区间"><a href="#2-构建区间" class="headerlink" title="2)    构建区间"></a>2)    构建区间</h3><p>区间实例可以由Range类的静态方法获取：</p>
<table>
<thead>
<tr>
<th>(a..b)</th>
<th>open(C, C)</th>
</tr>
</thead>
<tbody>
<tr>
<td>[a..b]</td>
<td>closed(C, C)</td>
</tr>
<tr>
<td>[a..b)</td>
<td>closedOpen(C, C)</td>
</tr>
<tr>
<td>(a..b]</td>
<td>openClosed(C, C)</td>
</tr>
<tr>
<td>(a..+∞)</td>
<td>greaterThan(C)</td>
</tr>
<tr>
<td>[a..+∞)</td>
<td>atLeast(C)</td>
</tr>
<tr>
<td>(-∞..b)</td>
<td>lessThan(C)</td>
</tr>
<tr>
<td>(-∞..b]</td>
<td>atMost(C)</td>
</tr>
<tr>
<td>(-∞..+∞)</td>
<td>all()</td>
</tr>
</tbody>
</table>
<p>此外，也可以明确地指定边界类型来构造区间：</p>
<table>
<thead>
<tr>
<th>有界区间</th>
<th>range(C, BoundType, C,   BoundType)</th>
</tr>
</thead>
<tbody>
<tr>
<td>无上界区间：((a..+∞) 或[a..+∞))</td>
<td>downTo(C, BoundType)</td>
</tr>
<tr>
<td>无下界区间：((-∞..b) 或(-∞..b])</td>
<td>upTo(C, BoundType)</td>
</tr>
</tbody>
</table>
<p>这里的BoundType是一个枚举类型，包含CLOSED和OPEN两个值。</p>
<h3 id="3-区间运算"><a href="#3-区间运算" class="headerlink" title="3)    区间运算"></a>3)    区间运算</h3><p>Range的基本运算是它的contains(C) 方法，和你期望的一样，它用来区间判断是否包含某个值。此外，Range实例也可以当作Predicate，并且在函数式编程中使用（译者注：见第4章）。任何Range实例也都支持containsAll(Iterable&lt;? extends C&gt;)方法：</p>
<h3 id="4-查询运算"><a href="#4-查询运算" class="headerlink" title="4)    查询运算"></a>4)    查询运算</h3><p>Range类提供了以下方法来 查看区间的端点：</p>
<p>hasLowerBound()和hasUpperBound()：判断区间是否有特定边界，或是无限的；</p>
<p>lowerBoundType()和upperBoundType()：返回区间边界类型，CLOSED或OPEN；如果区间没有对应的边界，抛出IllegalStateException；</p>
<p>lowerEndpoint()和upperEndpoint()：返回区间的端点值；如果区间没有对应的边界，抛出IllegalStateException；</p>
<p>isEmpty()：判断是否为空区间。</p>
<h3 id="5-关系运算"><a href="#5-关系运算" class="headerlink" title="5)    关系运算"></a>5)    关系运算</h3><p>a)        包含[enclose]</p>
<p>区间之间的最基本关系就是包含[encloses(Range)]：如果内区间的边界没有超出外区间的边界，则外区间包含内区间。包含判断的结果完全取决于区间端点的比较</p>
<p>b)        相连[isConnected]</p>
<p>Range.isConnected(Range)判断区间是否是相连的。具体来说，isConnected测试是否有区间同时包含于这两个区间，这等同于数学上的定义”两个区间的并集是连续集合的形式”（空区间的特殊情况除外）。</p>
<p>c)        交集[intersection]</p>
<p>Range.intersection(Range)返回两个区间的交集：既包含于第一个区间，又包含于另一个区间的最大区间。当且仅当两个区间是相连的，它们才有交集。如果两个区间没有交集，该方法将抛出IllegalArgumentException。</p>
<p>d)        跨区间[span]</p>
<p>Range.span(Range)返回”同时包括两个区间的最小区间”，如果两个区间相连，那就是它们的并集。</p>
<p>span是可互换的[commutative] 、关联的[associative] 、闭合的[closed]运算[operation]。</p>
<h3 id="6-离散域"><a href="#6-离散域" class="headerlink" title="6)    离散域"></a>6)    离散域</h3><p>部分（但不是全部）可比较类型是离散的，即区间的上下边界都是可枚举的。</p>
<p>在Guava中，用DiscreteDomain<c>实现类型C的离散形式操作。一个离散域总是代表某种类型值的全集；它不能代表类似”素数”、”长度为5的字符串”或”午夜的时间戳”这样的局部域。</c></p>
<p>DiscreteDomain提供的离散域实例包括：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>离散域</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>integers()</td>
</tr>
<tr>
<td>Long</td>
<td>longs()</td>
</tr>
</tbody>
</table>
<p>一旦获取了DiscreteDomain实例，你就可以使用下面的Range运算方法：</p>
<p>ContiguousSet.create(range, domain)：用ImmutableSortedSet<c>形式表示Range<c>中符合离散域定义的元素，并增加一些额外操作——译者注：实际返回ImmutableSortedSet的子类ContiguousSet。（对无限区间不起作用，除非类型C本身是有限的，比如int就是可枚举的）</c></c></p>
<p>canonical(domain)：把离散域转为区间的”规范形式”。如果ContiguousSet.create(a, domain).equals(ContiguousSet.create(b,domain))并且!a.isEmpty()，则有a.canonical(domain).equals(b.canonical(domain))。（这并不意味着a.equals(b)）</p>
<p>你可以创建自己的离散域，但必须记住DiscreteDomain契约的几个重要方面。</p>
<p>一个离散域总是代表某种类型值的全集；它不能代表类似”素数”或”长度为5的字符串”这样的局部域。所以举例来说，你无法构造一个DiscreteDomain以表示精确到秒的JODA DateTime日期集合：因为那将无法包含JODA DateTime的所有值。</p>
<p>DiscreteDomain可能是无限的——比如BigInteger DiscreteDomain。这种情况下，你应当用minValue()和maxValue()的默认实现，它们会抛出NoSuchElementException。但Guava禁止把无限区间传入ContiguousSet.create——译者注：那明显得不到一个可枚举的集合。</p>
<h2 id="9-I-O"><a href="#9-I-O" class="headerlink" title="9.     I/O"></a>9.     I/O</h2><h3 id="1-Guava-Files中的文件操作"><a href="#1-Guava-Files中的文件操作" class="headerlink" title="1)    Guava Files中的文件操作"></a>1)    Guava Files中的文件操作</h3><p>Java的基本API对文件的操作很繁琐，为了向文件中写入一行文本，都需要写十几行的代码。guava对此作了很多改进，提供了很多方便的操作。</p>
<h2 id="10-散列（Hash）"><a href="#10-散列（Hash）" class="headerlink" title="10.             散列（Hash）"></a>10.             散列（Hash）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1)    概述"></a>1)    概述</h3><p>Java内建的散列码[hash code]概念被限制为32位，并且没有分离散列算法和它们所作用的数据，因此很难用备选算法进行替换。此外，使用Java内建方法实现的散列码通常是劣质的，部分是因为它们最终都依赖于JDK类中已有的劣质散列码。</p>
<p>Object.hashCode往往很快，但是在预防碰撞上却很弱，也没有对分散性的预期。这使得它们很适合在散列表中运用，因为额外碰撞只会带来轻微的性能损失，同时差劲的分散性也可以容易地通过再散列来纠正（Java中所有合理的散列表都用了再散列方法）。然而，在简单散列表以外的散列运用中，Object.hashCode几乎总是达不到要求——因此，有了com.google.common.hash包。</p>
<h3 id="2-散列包的组成"><a href="#2-散列包的组成" class="headerlink" title="2)    散列包的组成"></a>2)    散列包的组成</h3><p>在这个包的Java doc中，我们可以看到很多不同的类，但是文档中没有明显地表明它们是怎样一起配合工作的。</p>
<p>a)        HashFunction</p>
<p>HashFunction是一个单纯的（引用透明的）、无状态的方法，它把任意的数据块映射到固定数目的位置，并且保证相同的输入一定产生相同的输出，不同的输入尽可能产生不同的输出。</p>
<p>b)        Hasher</p>
<p>HashFunction的实例可以提供有状态的Hasher，Hasher提供了流畅的语法把数据添加到散列运算，然后获取散列值。Hasher可以接受所有原生类型、字节数组、字节数组的片段、字符序列、特定字符集的字符序列等等，或者任何给定了Funnel实现的对象。</p>
<p>Hasher实现了PrimitiveSink接口，这个接口为接受原生类型流的对象定义了fluent风格的API</p>
<p>c)        Funnel</p>
<p>Funnel描述了如何把一个具体的对象类型分解为原生字段值，从而写入PrimitiveSink。</p>
<p>注：putString(“abc”,Charsets.UTF_8).putString(“def”, Charsets.UTF_8)完全等同于putString(“ab”, Charsets.UTF_8).putString(“cdef”,Charsets.UTF_8)，因为它们提供了相同的字节序列。这可能带来预料之外的散列冲突。增加某种形式的分隔符有助于消除散列冲突。</p>
<p>d)        HashCode</p>
<p>一旦Hasher被赋予了所有输入，就可以通过hash()方法获取HashCode实例（多次调用hash()方法的结果是不确定的）。HashCode可以通过asInt()、asLong()、asBytes()方法来做相等性检测，此外，writeBytesTo(array, offset, maxLength)把散列值的前maxLength字节写入字节数组。</p>
<h3 id="3-布鲁姆过滤器-BloomFilter"><a href="#3-布鲁姆过滤器-BloomFilter" class="headerlink" title="3)    布鲁姆过滤器[BloomFilter]"></a>3)    布鲁姆过滤器[BloomFilter]</h3><p>布鲁姆过滤器是哈希运算的一项优雅运用，它可以简单地基于Object.hashCode()实现。简而言之，布鲁姆过滤器是一种概率数据结构，它允许你检测某个对象是一定不在过滤器中，还是可能已经添加到过滤器了。</p>
<p>Guava散列包有一个内建的布鲁姆过滤器实现，你只要提供Funnel就可以使用它。你可以使用create(Funnel funnel, int expectedInsertions, doublefalsePositiveProbability)方法获取BloomFilter<t>，缺省误检率[falsePositiveProbability]为3%。BloomFilter<t>提供了booleanmightContain(T) 和void put(T)，它们的含义都不言自明了。</t></t></p>
<h3 id="4-Hashing类"><a href="#4-Hashing类" class="headerlink" title="4)    Hashing类"></a>4)    Hashing类</h3><p>Hashing类提供了若干散列函数，以及运算HashCode对象的工具方法。</p>
<p>已提供的散列函数</p>
<table>
<thead>
<tr>
<th>md5()</th>
<th>murmur3_128()</th>
<th>murmur3_32()</th>
<th>sha1()</th>
</tr>
</thead>
<tbody>
<tr>
<td>sha256()</td>
<td>sha512()</td>
<td>goodFastHash(int bits)</td>
</tr>
</tbody>
</table>
<p>HashCode运算</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashCode combineOrdered( Iterable<hashcode>)</hashcode></td>
<td>以有序方式联接散列码，如果两个散列集合用该方法联接出的散列码相同，那么散列集合的元素可能是顺序相等的</td>
</tr>
<tr>
<td>HashCode   combineUnordered( Iterable<hashcode>)</hashcode></td>
<td>以无序方式联接散列码，如果两个散列集合用该方法联接出的散列码相同，那么散列集合的元素可能在某种排序下是相等的</td>
</tr>
<tr>
<td>int   consistentHash( HashCode, int buckets)</td>
<td>为给定的”桶”大小返回一致性哈希值。当”桶”增长时，该方法保证最小程度的一致性哈希值变化。详见一致性哈希。</td>
</tr>
</tbody>
</table>
<h2 id="11-事件总线（EventBus）"><a href="#11-事件总线（EventBus）" class="headerlink" title="11.             事件总线（EventBus）"></a>11.             事件总线（EventBus）</h2><p>传统上，Java的进程内事件分发都是通过发布者和订阅者之间的显式注册实现的。设计EventBus就是为了取代这种显示注册方式，使组件间有了更好的解耦。EventBus不是通用型的发布-订阅实现，不适用于进程间通信。</p>
<h2 id="12-数学运算（Math）"><a href="#12-数学运算（Math）" class="headerlink" title="12.             数学运算（Math）"></a>12.             数学运算（Math）</h2><h2 id="13-反射（Reflection）"><a href="#13-反射（Reflection）" class="headerlink" title="13.             反射（Reflection）"></a>13.             反射（Reflection）</h2><h3 id="1-guava反射TypeToken解决泛型运行时类型擦除的问题"><a href="#1-guava反射TypeToken解决泛型运行时类型擦除的问题" class="headerlink" title="1)    guava反射TypeToken解决泛型运行时类型擦除的问题"></a>1)    guava反射TypeToken解决泛型运行时类型擦除的问题</h3><p>介绍guava中的TypeToken类解决java 运行时泛型类型擦除问题。</p>
<p>TypeToken的方法列表如下：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>getType()</strong></td>
<td>获得包装的java.lang.reflect.Type.</td>
</tr>
<tr>
<td><strong>getRawType()</strong></td>
<td>返回大家熟知的运行时类</td>
</tr>
<tr>
<td><strong>getSubtype(Class&lt;?&gt;)</strong></td>
<td>返回那些有特定原始类的子类型。举个例子，如果这有一个Iterable并且参数是List.class，那么返回将是List。</td>
</tr>
<tr>
<td><strong>getSupertype(Class&lt;?&gt;)</strong></td>
<td>产生这个类型的超类，这个超类是指定的原始类型。举个例子，如果这是一个Set并且参数是Iterable.class，结果将会是Iterable。</td>
</tr>
<tr>
<td><strong>isAssignableFrom(type)</strong></td>
<td>如果这个类型是 assignable from 指定的类型，并且考虑泛型参数，返回true。List&lt;? extends Number&gt;是assignable from List，但List没有.</td>
</tr>
<tr>
<td><strong>getTypes()</strong></td>
<td>返回一个Set，包含了这个所有接口，子类和类是这个类型的类。返回的Set同样提供了classes()和interfaces()方法允许你只浏览超类和接口类。</td>
</tr>
<tr>
<td><strong>isArray()</strong></td>
<td>检查某个类型是不是数组，甚至是&lt;? extends A[]&gt;。</td>
</tr>
<tr>
<td><strong>getComponentType()</strong></td>
<td>返回组件类型数组。</td>
</tr>
</tbody>
</table>
<h3 id="2-guava反射之Invokable使用"><a href="#2-guava反射之Invokable使用" class="headerlink" title="2)    guava反射之Invokable使用"></a>2)    guava反射之Invokable使用</h3><p>Guava的Invokable是对java.lang.reflect.Method和java.lang.reflect.Constructor的流式包装。它简化了常见的反射代码的使用。</p>
<p>一些使用例子：</p>
<p>a)        方法是否是public的?</p>
<p>JDK:</p>
<p>Modifier.isPublic(method.getModifiers());</p>
<p>Invokable:</p>
<p>invokable.isPublic();</p>
<p>b)        方法是否是package private?</p>
<p>JDK:</p>
<p>!(Modifier.isPrivate(method.getModifiers())||Modifier.isPublic(method.getModifiers()))</p>
<p>Invokable:</p>
<p>invokable.isPackagePrivate()</p>
<p>c)        方法是否能够被子类重写？</p>
<p>JDK:</p>
<p>!(Modifier.isFinal(method.getModifiers())</p>
<p>||Modifiers.isPrivate(method.getModifiers())</p>
<p>||Modifiers.isStatic(method.getModifiers())</p>
<p>||Modifiers.isFinal(method.getDeclaringClass().getModifiers()))<br>Invokable:</p>
<p>invokable.isOverridable()</p>
<p>d)        方法的第一个参数是否被定义了注解@Nullable？</p>
<p>JDK:</p>
<p>for (Annotation annotation : method.getParameterAnnotations[0]) {</p>
<p>​    if (annotation instanceof Nullable) {</p>
<p>​        return true;</p>
<p>​    }</p>
<p>}</p>
<p>return false;</p>
<p>Invokable:</p>
<p>invokable.getParameters().get(0).isAnnotationPresent(Nullable.class)</p>
<p>e)        构造函数和工厂方法如何共享同样的代码？</p>
<p>你是否很想重复自己，因为你的反射代码需要以相同的方式工作在构造函数和工厂方法中？</p>
<p>Invokable提供了一个抽象的概念。下面的代码适合任何一种方法或构造函数：</p>
<p>invokable.isPublic();</p>
<p>invokable.getParameters();</p>
<p>invokable.invoke(object,args);</p>
<p>List的List.get(int)返回类型是什么？</p>
<p>Invokable提供了与众不同的类型解决方案：</p>
<p>Invokable&lt;List<string>,?&gt; invokable = new TypeToken&lt;List<string>&gt;()        {}.method(getMethod);</string></string></p>
<p>invokable.getReturnType();// String.class</p>
<h3 id="3-guava反射：Reflection-newProxy方法简化动态代理"><a href="#3-guava反射：Reflection-newProxy方法简化动态代理" class="headerlink" title="3)    guava反射：Reflection.newProxy方法简化动态代理"></a>3)    guava反射：Reflection.newProxy方法简化动态代理</h3><p>原理上GoogleGuava的动态代理也是使用JDK的动态代理，这是做了封装，更加简便。另外一点是能够很好的检查需要代理的对象必须拥有接口。使用<code>Class`</code>类的<code></code>isInterface()`来做检查。</p>
<h2 id="14-注解（Annotations）"><a href="#14-注解（Annotations）" class="headerlink" title="14.             注解（Annotations）"></a>14.             注解（Annotations）</h2><p>com.google.common.annotations包下注解类的含义和用法：</p>
<h3 id="1-Beta"><a href="#1-Beta" class="headerlink" title="1)    Beta"></a><a href="">1)    Beta</a></h3><p>/**</p>
<ul>
<li><p>表明一个公用API的未来版本是受不兼容变更或删除限制的</p>
</li>
<li><p>拥有这个注释标志的API不受任何兼容性保证</p>
<p>*</p>
<p>*/</p>
</li>
</ul>
<p>@Retention(RetentionPolicy.CLASS)</p>
<p>@Target({</p>
<p>​        ElementType.ANNOTATION_TYPE,</p>
<p>​        ElementType.CONSTRUCTOR,</p>
<p>​        ElementType.FIELD,</p>
<p>​        ElementType.METHOD,</p>
<p>​        ElementType.TYPE})</p>
<p>@Documented</p>
<p>@GwtCompatible</p>
<p>public@interface Beta {}</p>
<h3 id="2-GwtCompatible"><a href="#2-GwtCompatible" class="headerlink" title="2)    GwtCompatible"></a>2)    GwtCompatible</h3><p>/**</p>
<ul>
<li><p>表明一个类型可能会与 Google WebToolkit 一起使用.</p>
</li>
<li><p>如果一个方法使用这个注释,说明这个方法的返回值是GWT 兼容的</p>
<p>*</p>
<p>*/</p>
</li>
</ul>
<p>@Retention(RetentionPolicy.CLASS)</p>
<p>@Target({ElementType.TYPE, ElementType.METHOD })</p>
<p>@Documented</p>
<p>@GwtCompatible</p>
<p>public@interface GwtCompatible {</p>
<p>​    /**</p>
<p>​     * 说明一个类型或者方法的返回值是否支持GWT 序列化</p>
<p>​     *</p>
<p>​     */</p>
<p>​    boolean serializable() default false;</p>
<p>​    /**</p>
<p>​     * 说明一个类型是否在 GWT 被模拟.</p>
<p>​     * 被模拟的源(父源)和JVM的实现不一样</p>
<p>​     *</p>
<p>​     */</p>
<p>​    boolean emulated() default false;</p>
<p>}</p>
<h3 id="3-GwtIncompatible"><a href="#3-GwtIncompatible" class="headerlink" title="3)    GwtIncompatible"></a>3)    GwtIncompatible</h3><p>/**</p>
<ul>
<li><p>说明一个方法可能无法与 GWT 一起使用</p>
</li>
<li><p>他只能用于被 @GwtCompatible标志的类的字段,方法和内部类</p>
<p>*</p>
<p>*/</p>
</li>
</ul>
<p>@Retention(RetentionPolicy.CLASS)</p>
<p>@Target({</p>
<p>​        ElementType.TYPE, ElementType.METHOD,</p>
<p>​        ElementType.CONSTRUCTOR,ElementType.FIELD })</p>
<p>@Documented</p>
<p>@GwtCompatible</p>
<p>public@interface GwtIncompatible {</p>
<p>​    /**</p>
<p>​     * 用于表示不兼容 GWT 的原因</p>
<p>​     *</p>
<p>​     */</p>
<p>​    String value();</p>
<p>}</p>
<h3 id="4-VisibleForTesting"><a href="#4-VisibleForTesting" class="headerlink" title="4)    VisibleForTesting"></a>4)    VisibleForTesting</h3><p>/**</p>
<p> *注释程序元素的存在,或比其他必要广泛可见,仅用于测试代码。</p>
<p>*/</p>
<p>@GwtCompatible</p>
<p>public@interface VisibleForTesting {</p>
<p>}</p>
<h2 id="15-网络编程（Net）"><a href="#15-网络编程（Net）" class="headerlink" title="15.             网络编程（Net）"></a>15.             网络编程（Net）</h2><p>guava中的net包目前提供的功能较少，而且大多类都标注了@Beta的注解，在guava中标记Beta注解表示这个类还不稳定，有可能在以后的版本中变化，或者去掉，所以不建议大量使用，这里也是只做简单的介绍。</p>
<p>先介绍下唯一一个没有Beta注解的类HttpHeaders，这个类中并没有实质的方法，只是定义了一些Http头名称的常量，通常如果需要我们会自己定义这些常量，如果你引用了guava包，那么就不再建议我们自己定义这些头名称的常量了，直接用它定义的即可。</p>
<p>这里面应该有几乎所有的Http头名称，例如：X_FORWARDED_FOR，UPGRADE，REFERER等等。用法也没有必要介绍了，直接引用常量就可以了。</p>
<p>再介绍下一个比较常用的小功能，有时候我们需要在配置文件中配置IP+端口，这时候需要自己写解析ip，端口的方法，guava为我们提供了解析类，我们看下用法实例：</p>
<p>HostAndPort  hostAndPort =HostAndPort.fromString(“127.0.0.1:8080”);</p>
<p>System.out.println(“host== “ + hostAndPort.getHostText());</p>
<p>System.out.println(“port== “ + hostAndPort.getPortOrDefault(80));</p>
<p>HostAndPort类的静态方法fromString(String)可以解析出字符串中定义的Host和端口信息。</p>
<p>另外guava包中还提供了InetAddresses类，这个类是InetAddress的帮助类，通过这个类可以方便的从字符串中解析出InetAddress类。但是此类也有@Beta的注解，所以要谨慎使用。</p>
<p>参考资料：<a href="http://ifeve.com/google-guava/" target="_blank" rel="noopener">http://ifeve.com/google-guava/</a></p>
<p><a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">https://code.google.com/p/guava-libraries/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/21/Java中的String，StringBuilder，StringBuffer三者的区别/" rel="next" title="Java中的String，StringBuilder，StringBuffer三者的区别">
                <i class="fa fa-chevron-left"></i> Java中的String，StringBuilder，StringBuffer三者的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/21/Guava快速入门/" rel="prev" title="Guava快速入门">
                Guava快速入门 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Duke Du</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基本工具（Basic-utilities）"><span class="nav-number">1.</span> <span class="nav-text">1.     基本工具（Basic utilities）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用和避免null（Optional）"><span class="nav-number">1.1.</span> <span class="nav-text">1)    使用和避免null（Optional）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-前提条件（Preconditions）"><span class="nav-number">1.2.</span> <span class="nav-text">2)    前提条件（Preconditions）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-常见的对象方法（Objects）"><span class="nav-number">1.3.</span> <span class="nav-text">3)    常见的对象方法（Objects）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-排序"><span class="nav-number">1.4.</span> <span class="nav-text">4)    排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Throwable类"><span class="nav-number">1.5.</span> <span class="nav-text">5)    Throwable类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-集合（Collections）"><span class="nav-number">2.</span> <span class="nav-text">2.     集合（Collections）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-google-guava的不可变集合"><span class="nav-number">2.1.</span> <span class="nav-text">1)    google guava的不可变集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-google-guava集合之Multiset"><span class="nav-number">2.2.</span> <span class="nav-text">2)    google guava集合之Multiset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-google-guava的BiMap：双向Map"><span class="nav-number">2.3.</span> <span class="nav-text">3)    google guava的BiMap：双向Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-google-guava的Multimaps：一键多值的Map"><span class="nav-number">2.4.</span> <span class="nav-text">4)    google guava的Multimaps：一键多值的Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-google-guava集合之Table"><span class="nav-number">2.5.</span> <span class="nav-text">5)    google guava集合之Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Guava集合：使用Iterators简化Iterator操作"><span class="nav-number">2.6.</span> <span class="nav-text">6)    Guava集合：使用Iterators简化Iterator操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ClassToInstanceMap可以实现map的key值是多个类型"><span class="nav-number">2.7.</span> <span class="nav-text">7)    ClassToInstanceMap可以实现map的key值是多个类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Ordering犀利的比较器"><span class="nav-number">2.8.</span> <span class="nav-text">8)    Ordering犀利的比较器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-ComparisonChain比较"><span class="nav-number">2.9.</span> <span class="nav-text">9)    ComparisonChain比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-缓存（Caches）"><span class="nav-number">3.</span> <span class="nav-text">3.     缓存（Caches）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用google-guava做内存缓存"><span class="nav-number">3.1.</span> <span class="nav-text">1)    使用google guava做内存缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-google-guava缓存分析"><span class="nav-number">3.2.</span> <span class="nav-text">2)    google guava缓存分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-函数式风格（Functional-idioms）"><span class="nav-number">4.</span> <span class="nav-text">4.     函数式风格（Functional idioms）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-并发（Concurrency）"><span class="nav-number">5.</span> <span class="nav-text">5.     并发（Concurrency）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Guava并发：ListenableFuture使用介绍以及示例"><span class="nav-number">5.1.</span> <span class="nav-text">1)    Guava并发：ListenableFuture使用介绍以及示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Guava并发：RateLimiter限制资源的并发访问线程数"><span class="nav-number">5.2.</span> <span class="nav-text">2)    Guava并发：RateLimiter限制资源的并发访问线程数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Guava并发：使用Monitor控制并发"><span class="nav-number">5.3.</span> <span class="nav-text">3)    Guava并发：使用Monitor控制并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-字符串处理（Strings）"><span class="nav-number">6.</span> <span class="nav-text">6.     字符串处理（Strings）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-连接器（Joiner）"><span class="nav-number">6.1.</span> <span class="nav-text">1)    连接器（Joiner）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-拆分器（Splitter）"><span class="nav-number">6.2.</span> <span class="nav-text">2)    拆分器（Splitter）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-字符匹配器（CharMatcher）"><span class="nav-number">6.3.</span> <span class="nav-text">3)    字符匹配器（CharMatcher）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-字符集（Charsets）"><span class="nav-number">6.4.</span> <span class="nav-text">4)    字符集（Charsets）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-大小写格式（CaseFormat）"><span class="nav-number">6.5.</span> <span class="nav-text">5)    大小写格式（CaseFormat）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-原生类型（Primitives）"><span class="nav-number">7.</span> <span class="nav-text">7.     原生类型（Primitives）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-区间（Ranges）"><span class="nav-number">8.</span> <span class="nav-text">8.     区间（Ranges）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-简介"><span class="nav-number">8.1.</span> <span class="nav-text">1)    简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-构建区间"><span class="nav-number">8.2.</span> <span class="nav-text">2)    构建区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-区间运算"><span class="nav-number">8.3.</span> <span class="nav-text">3)    区间运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-查询运算"><span class="nav-number">8.4.</span> <span class="nav-text">4)    查询运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-关系运算"><span class="nav-number">8.5.</span> <span class="nav-text">5)    关系运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-离散域"><span class="nav-number">8.6.</span> <span class="nav-text">6)    离散域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-I-O"><span class="nav-number">9.</span> <span class="nav-text">9.     I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Guava-Files中的文件操作"><span class="nav-number">9.1.</span> <span class="nav-text">1)    Guava Files中的文件操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-散列（Hash）"><span class="nav-number">10.</span> <span class="nav-text">10.             散列（Hash）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述"><span class="nav-number">10.1.</span> <span class="nav-text">1)    概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-散列包的组成"><span class="nav-number">10.2.</span> <span class="nav-text">2)    散列包的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-布鲁姆过滤器-BloomFilter"><span class="nav-number">10.3.</span> <span class="nav-text">3)    布鲁姆过滤器[BloomFilter]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Hashing类"><span class="nav-number">10.4.</span> <span class="nav-text">4)    Hashing类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-事件总线（EventBus）"><span class="nav-number">11.</span> <span class="nav-text">11.             事件总线（EventBus）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-数学运算（Math）"><span class="nav-number">12.</span> <span class="nav-text">12.             数学运算（Math）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-反射（Reflection）"><span class="nav-number">13.</span> <span class="nav-text">13.             反射（Reflection）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-guava反射TypeToken解决泛型运行时类型擦除的问题"><span class="nav-number">13.1.</span> <span class="nav-text">1)    guava反射TypeToken解决泛型运行时类型擦除的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-guava反射之Invokable使用"><span class="nav-number">13.2.</span> <span class="nav-text">2)    guava反射之Invokable使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-guava反射：Reflection-newProxy方法简化动态代理"><span class="nav-number">13.3.</span> <span class="nav-text">3)    guava反射：Reflection.newProxy方法简化动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-注解（Annotations）"><span class="nav-number">14.</span> <span class="nav-text">14.             注解（Annotations）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Beta"><span class="nav-number">14.1.</span> <span class="nav-text">1)    Beta</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-GwtCompatible"><span class="nav-number">14.2.</span> <span class="nav-text">2)    GwtCompatible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-GwtIncompatible"><span class="nav-number">14.3.</span> <span class="nav-text">3)    GwtIncompatible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-VisibleForTesting"><span class="nav-number">14.4.</span> <span class="nav-text">4)    VisibleForTesting</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-网络编程（Net）"><span class="nav-number">15.</span> <span class="nav-text">15.             网络编程（Net）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Duke Du</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
